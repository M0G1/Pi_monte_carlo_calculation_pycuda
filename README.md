# Pi_monte_carlo_calculation_pycuda

В данной лабораторной работе производилось замер ускорения в вычислении числа pi методом Монте-Карло.
В ходе выполнения работы были написаны функция ядра для вычисления на графическом процессоре в среде google.colab, а так же код с тем же самым алгоритмом при помощи стандартных библиотек python, а также модуля numpy.

Далее представлена таблица со значениями полученными в ходе эксперимента. Значения были округлены до 3-го знака после запятой, тогда как получались из чисел с двойной точностью.

N       | 16384 (2^14) | 32768 (2^15)  | 65536 (2^16)  | 131072 (2^17) | 262144 (2^18) | 524288 (2^19) | 1048576 (2^20) | 2097152 (2^21)  
 :---: |  :---: |  :---: |  :---: |  :---: |  :---: |  :---: |  :---: |  :---:
cpu (s) | 0.125 | 0.219 | 0.459 | 0.881 | 1.711 | 3.326 | 6.464 | 13.226  
gpu (s) | 0.210 | 0.206 | 0.206 | 0.205 | 0.207 | 0.206 | 0.221 | 0.237  
numpy (s)  | 0.001 | 0.002 | 0.003 | 0.005 | 0.009 | 0.018 | 0.033 | 0.071  
acceleration cpu/gpu | 0.593 | 1.064 | 2.232 | 4.304 | 8.284 | 16.132 | 29.277 | 55.776  
acceleration numpy/gpu | 0.004 | 0.008 | 0.016 | 0.026 | 0.043 | 0.086 | 0.152 | 0.299  
acceleration cpu/numpy | 155.666 | 141.781 | 142.052 | 166.914 | 194.771 | 186.761 | 192.993 | 186.53  

Замер времени проводился с учетом генерации случайных значений.
Как видно графический процессор дает ускорение для размеров данных больше чем 16384, при меньших значениях имеет место замедление из-за недостаточно большого числа данных.
Однако для столь тривиальной задачи лучше подходит модуль numpy, который по своей скорости работы для данного задания подходит лучше, что видно по значению отношения времени выполнения кода с использованием numpy к функции ядра cuda.
При этом значения числа pi в среднем было точнее посчитано именно модулем numpy(вывод кода программы ).
